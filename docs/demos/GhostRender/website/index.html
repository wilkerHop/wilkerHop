<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GhostRender: Decoupling Math from Pixels</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>GhostRender</h1>
            <p>Decoupling Math from Pixels</p>
        </header>

        <main>
            <section>
                <h2>The Problem</h2>
                <p>
                    <strong>Why calculate physics in Python when Rust exists?</strong>
                </p>
                <p>
                    We love Blender's Python API. It's flexible, accessible, and great for tooling. 
                    But when you're calculating millions of particle positions or complex wave functions per frame, 
                    Python's Global Interpreter Lock (GIL) and dynamic typing become a bottleneck.
                </p>
                <p>
                    <span class="highlight">The frame rate drops. The viewport stutters. The artist waits.</span>
                </p>
            </section>

            <section>
                <h2>The Solution</h2>
                <p>
                    <strong>GhostRender</strong> proposes a radical shift: <span class="highlight">The Pipeline Approach</span>.
                </p>
                <p>
                    Instead of asking Blender to <em>think</em>, we only ask it to <em>draw</em>. 
                    We move the heavy lifting to <strong>Rust</strong>, a systems programming language known for blazing speed and memory safety.
                </p>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <span class="stat-value">Rust</span>
                        <span class="stat-label">The Brain</span>
                        <p style="font-size: 0.8rem; margin-top: 0.5rem;">Calculates pure math & physics.</p>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value">Python</span>
                        <span class="stat-label">The Bridge</span>
                        <p style="font-size: 0.8rem; margin-top: 0.5rem;">Auto-generated script with baked keyframes.</p>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value">Blender</span>
                        <span class="stat-label">The Artist</span>
                        <p style="font-size: 0.8rem; margin-top: 0.5rem;">Renders pixels in headless mode.</p>
                    </div>
                </div>
            </section>

            <section>
                <h2>The Code</h2>
                <p>
                    Here is the heart of the engine. Rust computes the sine wave position for every cube, for every frame, in microseconds.
                </p>
<pre style="background: #000; color: #fff; padding: 1rem; border: 4px solid var(--text-color); overflow-x: auto;"><code>// src/main.rs
for frame in 0..FRAMES {
    for cube_index in 0..NUM_CUBES {
        let time_step = frame as f32 * 0.2;
        let offset = cube_index as f32 * 0.5;
        
        // Pure math, zero overhead
        let z_pos = (time_step + offset).sin() * 3.0;
        
        // Write to Python script buffer
        writeln!(file, "cube = bpy.data.objects['Cube.{}']", cube_index)?;
        writeln!(file, "cube.location.z = {:.4}", z_pos)?;
        writeln!(file, "cube.keyframe_insert(data_path='location', frame={})", frame + 1)?;
    }
}</code></pre>
                <p>
                    This generates a massive, flat Python script. No loops, no logic, just raw data assignment. Blender eats this for breakfast.
                </p>
            </section>

            <section>
                <h2>The Evidence</h2>
                <p>
                    Talk is cheap. Here is the artifact produced automatically by our CI pipeline on the latest commit.
                </p>
                
                <div class="video-container">
                    <video controls autoplay loop muted>
                        <source src="animation_output.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                </div>
                
                <p>
                    <em>10 cubes, 60 frames, rendered headless on GitHub Actions runners.</em>
                </p>
            </section>

            <section>
                <h2>The "Gotchas"</h2>
                <p>
                    Building this wasn't free. We learned that headless rendering on Linux requires a virtual framebuffer (XVFB).
                </p>
                <p class="highlight">
                    Error: "Unable to open a display"
                </p>
                <p>
                    We fixed this by installing <code>xvfb</code> and <code>libgl1-mesa-dri</code> in our CI environment, and running Blender with <code>xvfb-run</code>.
                </p>
            </section>
        </main>

        <footer>
            <p>
                <a href="https://github.com/wilkerHop/GhostRender">View Source on GitHub</a>
            </p>
            <p>
                Generated at: <script>document.write(new Date().toUTCString());</script>
            </p>
        </footer>
    </div>
</body>
</html>
